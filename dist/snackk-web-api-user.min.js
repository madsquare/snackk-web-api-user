(function (root, factory) {
  if (typeof define === 'function') {
    define(['server','lodash'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.user = factory();
  }
}(this, function () {/**
 * almond 0.1.2 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var defined = {},
        waiting = {},
        config = {},
        defining = {},
        aps = [].slice,
        main, req;

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {},
            nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part;

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; (part = name[i]); i++) {
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            return true;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (waiting.hasOwnProperty(name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!defined.hasOwnProperty(name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    function makeMap(name, relName) {
        var prefix, plugin,
            index = name.indexOf('!');

        if (index !== -1) {
            prefix = normalize(name.slice(0, index), relName);
            name = name.slice(index + 1);
            plugin = callDep(prefix);

            //Normalize according
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            p: plugin
        };
    }

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    main = function (name, deps, callback, relName) {
        var args = [],
            usingExports,
            cjsModule, depName, ret, map, i;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i++) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = makeRequire(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = defined[name] = {};
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = {
                        id: name,
                        uri: '',
                        exports: defined[name],
                        config: makeConfig(name)
                    };
                } else if (defined.hasOwnProperty(depName) || waiting.hasOwnProperty(depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else if (!defining[depName]) {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync) {
        if (typeof deps === "string") {
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 15);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        waiting[name] = [name, deps, callback];
    };

    define.amd = {
        jQuery: true
    };
}());
define("../almond", function(){});

(function() {
  define('user',['server'], function(server) {
    var User, _ERROR_CODE, _callbackObj, _user;
    _user = null;
    _ERROR_CODE = {
      DUPLICATED: 'error_duplicated',
      INVALID: 'error_invalid',
      UN_KNOWN: 'error_unknown'
    };
    _callbackObj = {
      success: (function(_this) {
        return function(res) {
          if (callback && callback.success) {
            return callback.success(res);
          }
        };
      })(this),
      error: (function(_this) {
        return function(er) {
          if (callback && callback.error) {
            return callback.error(er);
          }
        };
      })(this),
      complete: function() {
        if (callback && callback.complete) {
          return callback.complete();
        }
      }
    };
    User = {

      /*
       * set user
       * @param {User} user  :user object
       */
      setUser: function(user) {
        return _user = user;
      },

      /*
       * 회원가입
       * @param  {User}   user     : user object
       * @param  {Function} callback 
       * @param  {Object} options  
       * @return {ajax}
       */
      registUser: function(user, callback, options) {
        if (!options) {
          options = {};
        }
        return server.request(server.TAG.user.user, _.assign({
          'data': _.assign({
            'user': user
          }, options)
        }, {
          'type': 'POST'
        }, callback));
      },

      /*
       * 로그인 provider추가.
       * @param {String}   sns      : sns 종류.
       * @param {String}   token    : sns access token
       * @param {Function} callback
       */
      addProvider: function(sns, token, callback) {
        var tag;
        tag = server.TAG.user.provider.replace(':us_no', _user.us_no).replace(':provider', sns);
        return server.request(tag, _.aasign({
          'type': 'POST',
          'data': {
            'token': token
          }
        }, callback));
      },

      /*
       * 내 정보 반환
       * @param  {Object}   filter   : http://api.snackk.tv/api/user.html#GET /user
       * @param  {Function} callback 
       * @param  {Object}   options  
       * @return {ajax}
       */
      loadMe: function(callback, options) {
        if (!options) {
          options = {};
        }
        return server.request(server.TAG.user.user, _.assign({
          'data': options
        }, callback));
      },

      /*
       * 해당 유저의 디폴트 이미지 로드.
       * @param  {Function} callback 
       * @return {ajax}
       */
      loadDefaultPicture: function(callback) {
        var tag;
        tag = server.TAG.user.profileDefault.replace(':us_no', _user.us_no);
        return server.request(tag, callback);
      },

      /*
       * 내 정보 수정.
       * 프로필은 제외됨.
       * @param  {User}     user     
       * @param  {Function} callback 
       * @param  {Object}   options  
       * @return {ajax}
       */
      updateUser: function(user, callback, options) {
        var tag;
        if (!_user) {
          console.log('updateUser] user object is empty.');
          return;
        }
        if (!options) {
          options = {};
        }
        tag = server.TAG.user.aUser.replace(':us_no', _user.us_no);
        return server.request(tag, _.assign({
          'type': 'PUT',
          'data': _.assign({
            'user': user
          }, options)
        }, callback));
      },

      /*
       * 프로필 사진 수정.
       * @param  {File}     fileInput [description]
       * @param  {Function} callback  [description]
       * @return {[type]}             [description]
       */
      updateProfile: function(fileInput, callback) {
        var tag;
        tag = server.TAG.user.profile.replace(':us_no', _user.us_no);
        return server.request(tag, _.assign({
          'fileInput': fileInput,
          'dataType': 'iframe json'
        }, callback));
      },

      /*
       * 비밀번호 변경.
       * @param  {String}   oldPasswd : 이전 비밀번호 입력.(optional)
       * @param  {String}   newPasswd : 새 비밀번호.
       * @param  {Function} callback 
       * @param  {Object}   options  
       * @return {ajax}
       */
      updatePassword: function(oldPasswd, newPasswd, callback, options) {
        var nonce, oldPasswdObj, tag, userObj;
        if (oldPasswd) {
          oldPasswdObj = {
            'passwd': oldPasswd
          };
          nonce = {
            'nonce': {
              'isPasswdEdit': 1
            }
          };
        } else {
          oldPasswdObj = {};
          nonce = {};
        }
        if (!options) {
          options = {};
        }
        userObj = _.assign({
          'new_passwd': newPassWd
        }, oldPasswdObj);
        tag = server.TAG.user.aUser.replace(':us_no', _user.us_no);
        return server.request(tag, _.aasign({
          'type': 'PUT',
          'data': _.assign({
            'user': userObj
          }, nonce, options)
        }, callback));
      },

      /*
       * 회원탈퇴.
       * @param  {Function} callback
       * @return {ajax}
       */
      deleteUser: function(callback) {
        var tag;
        if (!_user) {
          console.log('deleteUser] user object is empty.');
          return;
        }
        tag = server.TAG.user.aUser.replace(':us_no', _user.us_no);
        return server.request(tag, _.assign({
          'type': 'DELETE'
        }, callback));
      },

      /*
       * login provider 삭제.
       * @param  {String}   sns      : 삭제할 sns 종류.
       * @param  {Function} callback 
       * @return {ajax}
       */
      deleteProvider: function(sns, callback) {
        var tag;
        tag = server.TAG.user.provider.replace(':us_no', _user.us_no).replace(':provider', sns);
        return server.request(tag, _.assign({
          'type': 'DELETE'
        }, callback));
      },

      /*
       * 프로필 이미지 삭제.
       * @param  {Function} callback 
       * @return {ajax}
       */
      deletePicture: function(callback) {
        var tag;
        tag = server.TAG.user.profile.replace(':us_no', _user.us_no);
        return server.request(tag, _.assign({
          'type': 'DELETE'
        }, callback));
      },

      /*
       * 인증 메일 발송.
       * @param  {Function} callback 
       * @return {ajax}
       */
      sendEmail: function(callback) {
        var tag;
        tag = server.TAG.user.emailPost;
        return server.request(tag, callback);
      },

      /*
       * email 중복 및 유효성 검사.
       * @param  {String}   email    
       * @param  {Function} callback
       * @return {ajax}
       */
      validateEmail: function(email, callback) {
        var filter, xhr;
        if (!callback || !email) {
          console.error('validateEmail] email or callback is not defined.');
          return;
        }
        if (!email.match(/^(([a-zA-Z]|[0-9])|([-]|[_]|[.]))+[@](([a-zA-Z0-9])|([-])){2,63}[.](([a-zA-Z0-9]){2,63})+$/gi)) {
          callback('ERROR', _ERROR_CODE.INVALID);
        }
        xhr && xhr.abort();
        filter = {
          'filter': {
            'email': email
          }
        };
        return xhr = this.loadUser(filter, {
          success: (function(_this) {
            return function(res) {
              return callback('ERROR', _ERROR_CODE.DUPLICATED);
            };
          })(this),
          error: (function(_this) {
            return function(er) {
              if (er.code === 404) {
                return callback('SUCCESS');
              } else {
                return callback('ERROR', _ERROR_CODE.UN_KNOWN);
              }
            };
          })(this),
          complete: (function(_this) {
            return function() {
              return xhr = null;
            };
          })(this)
        });
      }
    };
    return User;
  });

}).call(this);

//# sourceMappingURL=user.js.map
;
    define('server', function (server) {
        return window.require('server');
    });
    return require('user');
}));
//# sourceMappingURL=snackk-web-api-user.min.js.map